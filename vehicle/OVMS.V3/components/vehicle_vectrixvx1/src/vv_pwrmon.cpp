/**
 * Project:      Open Vehicle Monitor System
 * Module:       Renault Twizy power monitor
 *
 * (c) 2017  Michael Balzer <dexter@dexters-web.de>
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */

#include "ovms_log.h"
static const char *TAG = "v-vx1";

#include <math.h>

#include "vv_pwrmon.h"
#include "metrics_standard.h"

#include "vehicle_vectrixvx1.h"

// BEGIN Power metrics names
// DO NOT EDIT -- generated by gen_metrics_names.sh
const char* const x_vv_p_stats_speed_dist[] = { "xvv.p.stats.cst.dist", "xvv.p.stats.acc.dist", "xvv.p.stats.dec.dist" };
const char* const x_vv_p_stats_speed_used[] = { "xvv.p.stats.cst.used", "xvv.p.stats.acc.used", "xvv.p.stats.dec.used" };
const char* const x_vv_p_stats_speed_recd[] = { "xvv.p.stats.cst.recd", "xvv.p.stats.acc.recd", "xvv.p.stats.dec.recd" };
const char* const x_vv_p_stats_speed_spdavg[] = { "xvv.p.stats.cst.spdavg", "xvv.p.stats.acc.spdavg", "xvv.p.stats.dec.spdavg" };
const char* const x_vv_p_stats_level_dist[] = { "xvv.p.stats.lup.dist", "xvv.p.stats.ldn.dist" };
const char* const x_vv_p_stats_level_used[] = { "xvv.p.stats.lup.used", "xvv.p.stats.ldn.used" };
const char* const x_vv_p_stats_level_recd[] = { "xvv.p.stats.lup.recd", "xvv.p.stats.ldn.recd" };
const char* const x_vv_p_stats_level_hsum[] = { "xvv.p.stats.lup.hsum", "xvv.p.stats.ldn.hsum" };
// END Power metrics names


/**
 * vehicle_vx1_power: command wrapper for CommandPower
 */
void vehicle_vx1_power(int verbosity, OvmsWriter* writer, OvmsCommand* cmd, int argc, const char* const* argv)
{
  OvmsVehicleVectrixVX1* vx1 = (OvmsVehicleVectrixVX1*) MyVehicleFactory.ActiveVehicle();
  string type = StdMetrics.ms_v_type->AsString();

  if (!vx1 || type != "RT")
  {
    writer->puts("Error: VX1 vehicle module not selected");
    return;
  }

  vx1->CommandPower(verbosity, writer, cmd, argc, argv);
}


/**
 * PowerInit:
 */
void OvmsVehicleVectrixVX1::PowerInit()
{
  ESP_LOGI(TAG, "pwrmon subsystem init");

  // init metrics

  vx1_speedpwr[0].InitMetrics(0, Kph);
  vx1_speedpwr[1].InitMetrics(1, KphPS);
  vx1_speedpwr[2].InitMetrics(2, KphPS);

  vx1_levelpwr[0].InitMetrics(0);
  vx1_levelpwr[1].InitMetrics(1);

  // init commands

  cmd_power = cmd_xvv->RegisterCommand("power", "Power/energy info");
  {
    cmd_power->RegisterCommand("report", "Trip efficiency report", vehicle_vx1_power);
    cmd_power->RegisterCommand("totals", "Power totals", vehicle_vx1_power);
    cmd_power->RegisterCommand("stats", "Generate RT-PWR-Stats entry", vehicle_vx1_power);
  }

}


/**
 * PowerUpdateMetrics: publish metrics
 */
void OvmsVehicleVectrixVX1::PowerUpdateMetrics()
{
  unsigned long pwr;

  pwr = vx1_speedpwr[CAN_SPEED_CONST].use
      + vx1_speedpwr[CAN_SPEED_ACCEL].use
      + vx1_speedpwr[CAN_SPEED_DECEL].use;

  *StdMetrics.ms_v_bat_energy_used = (float) pwr / WH_DIV / 1000;
  *StdMetrics.ms_v_bat_coulomb_used = (float) vx1_charge_use / AH_DIV;

  pwr = vx1_speedpwr[CAN_SPEED_CONST].rec
      + vx1_speedpwr[CAN_SPEED_ACCEL].rec
      + vx1_speedpwr[CAN_SPEED_DECEL].rec;

  *StdMetrics.ms_v_bat_energy_recd = (float) pwr / WH_DIV / 1000;
  *StdMetrics.ms_v_bat_coulomb_recd = (float) vx1_charge_rec / AH_DIV;

  for (speedpwr &stats : vx1_speedpwr)
    stats.UpdateMetrics();

  for (levelpwr &stats : vx1_levelpwr)
    stats.UpdateMetrics();

}


/**
 * PowerUpdate: collect new data & publish metrics
 */
void OvmsVehicleVectrixVX1::PowerUpdate()
{
  PowerCollectData();
  PowerUpdateMetrics();
}


/**
 * PowerIsModified: get & clear metrics modification flags
 */
bool OvmsVehicleVectrixVX1::PowerIsModified()
{
  bool modified = false;

  for (speedpwr &stats : vx1_speedpwr)
    modified |= stats.IsModified(m_modifier);

  for (levelpwr &stats : vx1_levelpwr)
    modified |= stats.IsModified(m_modifier);

  return modified;
}


/**
 * PowerCollectData:
 */
void OvmsVehicleVectrixVX1::PowerCollectData()
{
  long dist;
  int alt_diff, grade_perc;
  unsigned long coll_use, coll_rec;

  bool car_stale_gps = StdMetrics.ms_v_pos_gpslock->IsStale();
  int car_altitude = StdMetrics.ms_v_pos_altitude->AsInt();

  if ((vx1_status & CAN_STATUS_KEYON) == 0)
  {
    // CAR is turned off
    return;
  }
  else if (car_stale_gps == 0)
  {
    // no GPS for 2 minutes: reset section
    vx1_level_odo = 0;
    vx1_level_alt = 0;

    return;
  }
  else if (vx1_level_odo == 0)
  {
    // start new section:

    vx1_level_odo = vx1_odometer;
    vx1_level_alt = car_altitude;

    vx1_level_use = 0;
    vx1_level_rec = 0;

    return;
  }

  // calc section length:
  dist = (vx1_odometer - vx1_level_odo) * 10;
  if (dist < CAN_LEVEL_MINSECTLEN)
  {
    // section too short to collect
    return;
  }

  // OK, read + reset collected power sums:
  coll_use = vx1_level_use;
  coll_rec = vx1_level_rec;
  vx1_level_use = 0;
  vx1_level_rec = 0;

  // calc grade in percent:
  alt_diff = car_altitude - vx1_level_alt;
  grade_perc = (long) alt_diff * 100L / (long) dist;

  // set new section reference:
  vx1_level_odo = vx1_odometer;
  vx1_level_alt = car_altitude;

  // collect:
  if (grade_perc >= CAN_LEVEL_THRESHOLD)
  {
    vx1_levelpwr[CAN_LEVEL_UP].dist += dist; // in m
    vx1_levelpwr[CAN_LEVEL_UP].hsum += alt_diff; // in m
    vx1_levelpwr[CAN_LEVEL_UP].use += coll_use;
    vx1_levelpwr[CAN_LEVEL_UP].rec += coll_rec;
  }
  else if (grade_perc <= -CAN_LEVEL_THRESHOLD)
  {
    vx1_levelpwr[CAN_LEVEL_DOWN].dist += dist; // in m
    vx1_levelpwr[CAN_LEVEL_DOWN].hsum += -alt_diff; // in m
    vx1_levelpwr[CAN_LEVEL_DOWN].use += coll_use;
    vx1_levelpwr[CAN_LEVEL_DOWN].rec += coll_rec;
  }

}


/**
 * PowerReset:
 */
void OvmsVehicleVectrixVX1::PowerReset()
{
  ESP_LOGD(TAG, "pwrmon reset");

  for (speedpwr &stats : vx1_speedpwr)
  {
    stats.dist = 0;
    stats.use = 0;
    stats.rec = 0;
    stats.spdsum = 0;
    stats.spdcnt = 0;
  }

  for (levelpwr &stats : vx1_levelpwr)
  {
    stats.dist = 0;
    stats.use = 0;
    stats.rec = 0;
    stats.hsum = 0;
  }

  vx1_speed_state = CAN_SPEED_CONST;
  vx1_speed_distref = vx1_dist;
  vx1_level_use = 0;
  vx1_level_rec = 0;
  vx1_charge_use = 0;
  vx1_charge_rec = 0;

  vx1_level_odo = 0;
  vx1_level_alt = 0;

  vx1_cc_charge = 0;
  vx1_cc_soc = 0;
  vx1_cc_power_level = 0;

  PowerUpdateMetrics();
}




void speedpwr::InitMetrics(int i, metric_unit_t spdunit)
{
  m_dist = MyMetrics.InitFloat(x_vv_p_stats_speed_dist[i], SM_STALE_HIGH, 0, Kilometers);
  m_used = MyMetrics.InitFloat(x_vv_p_stats_speed_used[i], SM_STALE_HIGH, 0, kWh);
  m_recd = MyMetrics.InitFloat(x_vv_p_stats_speed_recd[i], SM_STALE_HIGH, 0, kWh);
  m_spdavg = MyMetrics.InitFloat(x_vv_p_stats_speed_spdavg[i], SM_STALE_HIGH, 0, spdunit);
  m_spdunit = spdunit;
}

void speedpwr::UpdateMetrics()
{
  *m_dist = (float) dist / 10000;
  *m_used = (float) use / WH_DIV / 1000;
  *m_recd = (float) rec / WH_DIV / 1000;
  if (spdcnt > 0)
    *m_spdavg = (float) (spdsum / spdcnt) / ((m_spdunit==Kph) ? 100 : 10);
  else
    *m_spdavg = (float) 0;
}

bool speedpwr::IsModified(size_t m_modifier)
{
  bool modified =
    m_dist->IsModifiedAndClear(m_modifier) |
    m_used->IsModifiedAndClear(m_modifier) |
    m_recd->IsModifiedAndClear(m_modifier) |
    m_spdavg->IsModifiedAndClear(m_modifier);
  return modified;
}


void levelpwr::InitMetrics(int i)
{
  m_dist = MyMetrics.InitFloat(x_vv_p_stats_level_dist[i], SM_STALE_HIGH, 0, Kilometers);
  m_hsum = MyMetrics.InitFloat(x_vv_p_stats_level_hsum[i], SM_STALE_HIGH, 0, Meters);
  m_used = MyMetrics.InitFloat(x_vv_p_stats_level_used[i], SM_STALE_HIGH, 0, kWh);
  m_recd = MyMetrics.InitFloat(x_vv_p_stats_level_recd[i], SM_STALE_HIGH, 0, kWh);
}

void levelpwr::UpdateMetrics()
{
  *m_dist = (float) dist / 1000;
  *m_hsum = (float) hsum;
  *m_used = (float) use / WH_DIV / 1000;
  *m_recd = (float) rec / WH_DIV / 1000;
}

bool levelpwr::IsModified(size_t m_modifier)
{
  bool modified =
    m_dist->IsModifiedAndClear(m_modifier) |
    m_used->IsModifiedAndClear(m_modifier) |
    m_recd->IsModifiedAndClear(m_modifier) |
    m_hsum->IsModifiedAndClear(m_modifier);
  return modified;
}


/**
 * CommandPower: power report|totals|stats
 *  totals: output current totals (text notification)
 *  report: output trip efficiency report (text notification)
 *  stats: output history entry RT-PWR-Stats
 */
OvmsVehicleVectrixVX1::vehicle_command_t OvmsVehicleVectrixVX1::CommandPower(int verbosity, OvmsWriter* writer, OvmsCommand* cmd, int argc, const char* const* argv)
{
  UINT8 i;

  ESP_LOGV(TAG, "command power %s, verbosity=%d", cmd->GetName(), verbosity);

  if (strcmp(cmd->GetName(), "stats") == 0)
  {
    /* Output power usage statistics:
     *
     * RT-PWR-Stats,0,86400
     *  ,<speed_CONST_dist>,<speed_CONST_use>,<speed_CONST_rec>
     *  ,<speed_ACCEL_dist>,<speed_ACCEL_use>,<speed_ACCEL_rec>
     *  ,<speed_DECEL_dist>,<speed_DECEL_use>,<speed_DECEL_rec>
     *  ,<level_UP_dist>,<level_UP_hsum>,<level_UP_use>,<level_UP_rec>
     *  ,<level_DOWN_dist>,<level_DOWN_hsum>,<level_DOWN_use>,<level_DOWN_rec>
     *  ,<speed_CONST_cnt>,<speed_CONST_sum>
     *  ,<speed_ACCEL_cnt>,<speed_ACCEL_sum>
     *  ,<speed_DECEL_cnt>,<speed_DECEL_sum>
     *  ,<charge_used>,<charge_recd>
     *
     * (cnt = 1/10 seconds, CONST_sum = speed, other sum = delta)
     */

    if (verbosity < 200)
      return Fail;

    writer->printf("RT-PWR-Stats,0,86400");

    for (i=0; i<=2; i++)
    {
      writer->printf(",%lu,%lu,%lu,%lu,%lu",
        vx1_speedpwr[i].dist / 10,
        vx1_speedpwr[i].use / WH_DIV,
        vx1_speedpwr[i].rec / WH_DIV,
        vx1_speedpwr[i].spdcnt,
        vx1_speedpwr[i].spdsum);
    }

    for (i=0; i<=1; i++)
    {
      writer->printf(",%lu,%u,%lu,%lu",
        vx1_levelpwr[i].dist,
        vx1_levelpwr[i].hsum,
        vx1_levelpwr[i].use / WH_DIV,
        vx1_levelpwr[i].rec / WH_DIV);
    }

    writer->printf(",%.2f,%.2f",
      (float) vx1_charge_use / AH_DIV,
      (float) vx1_charge_rec / AH_DIV);

    return Success;
  }


  // Gather common data for text reports:

  unsigned long pwr_dist, pwr_use, pwr_rec, odo_dist;
  UINT8 prc_const = 0, prc_accel = 0, prc_decel = 0;

  // overall sums:
  pwr_dist = vx1_speedpwr[CAN_SPEED_CONST].dist
          + vx1_speedpwr[CAN_SPEED_ACCEL].dist
          + vx1_speedpwr[CAN_SPEED_DECEL].dist;

  pwr_use = vx1_speedpwr[CAN_SPEED_CONST].use
          + vx1_speedpwr[CAN_SPEED_ACCEL].use
          + vx1_speedpwr[CAN_SPEED_DECEL].use;

  pwr_rec = vx1_speedpwr[CAN_SPEED_CONST].rec
          + vx1_speedpwr[CAN_SPEED_ACCEL].rec
          + vx1_speedpwr[CAN_SPEED_DECEL].rec;

  odo_dist = vx1_odometer - vx1_odometer_tripstart;

  // distribution:
  if (pwr_dist > 0)
  {
    prc_const = (vx1_speedpwr[CAN_SPEED_CONST].dist * 1000 / pwr_dist + 5) / 10;
    prc_accel = (vx1_speedpwr[CAN_SPEED_ACCEL].dist * 1000 / pwr_dist + 5) / 10;
    prc_decel = (vx1_speedpwr[CAN_SPEED_DECEL].dist * 1000 / pwr_dist + 5) / 10;
  }

  if ((pwr_use == 0) || (pwr_dist <= 10))
  {
    // not driven: only output power totals:
    writer->printf("Power -%lu +%lu Wh\n",
      (pwr_use + WH_RND) / WH_DIV,
      (pwr_rec + WH_RND) / WH_DIV);
  }

  else if (strcmp(cmd->GetName(), "totals") == 0)
  {
    /* Output power totals:
     *
     * Template:
     *    Power -1234 +1234 Wh 123.4 km
     *    Const 12% -1234 +1234 Wh
     *    Accel 12% -1234 +1234 Wh
     *    Decel 12% -1234 +1234 Wh
     *    Up 1234m -1234 +1234 Wh
     *    Down 1234m -1234 +1234 Wh
     *
     * Size:
     *  30 + 3*25 + 24 + 26 → 155
     *  COMMAND_RESULT_MINIMAL: omit Up/Down → 105
     */

    if (verbosity >= COMMAND_RESULT_MINIMAL)
    {
      writer->printf(
        "Power -%lu +%lu Wh %.1f km\n"
        "Const %d%% -%lu +%lu Wh\n"
        "Accel %d%% -%lu +%lu Wh\n"
        "Decel %d%% -%lu +%lu Wh\n",
        (pwr_use + WH_RND) / WH_DIV,
        (pwr_rec + WH_RND) / WH_DIV,
        (float) odo_dist / 100,
        prc_const,
        (vx1_speedpwr[CAN_SPEED_CONST].use + WH_RND) / WH_DIV,
        (vx1_speedpwr[CAN_SPEED_CONST].rec + WH_RND) / WH_DIV,
        prc_accel,
        (vx1_speedpwr[CAN_SPEED_ACCEL].use + WH_RND) / WH_DIV,
        (vx1_speedpwr[CAN_SPEED_ACCEL].rec + WH_RND) / WH_DIV,
        prc_decel,
        (vx1_speedpwr[CAN_SPEED_DECEL].use + WH_RND) / WH_DIV,
        (vx1_speedpwr[CAN_SPEED_DECEL].rec + WH_RND) / WH_DIV);
    }

    if (verbosity >= COMMAND_RESULT_SMS)
    {
      writer->printf(
        "Up %lum -%lu +%lu Wh\n"
        "Down %lum -%lu +%lu Wh\n",
        vx1_levelpwr[CAN_LEVEL_UP].hsum,
        (vx1_levelpwr[CAN_LEVEL_UP].use + WH_RND) / WH_DIV,
        (vx1_levelpwr[CAN_LEVEL_UP].rec + WH_RND) / WH_DIV,
        vx1_levelpwr[CAN_LEVEL_DOWN].hsum,
        (vx1_levelpwr[CAN_LEVEL_DOWN].use + WH_RND) / WH_DIV,
        (vx1_levelpwr[CAN_LEVEL_DOWN].rec + WH_RND) / WH_DIV);
    }

  }

  else
  {
    /* Output power efficiency trip report (default):
     *
     * Template:
     *    Trip 12.3km 12.3kph 123Wpk/12% SOC-12.3%=12.3%
     *    === 12% 123Wpk/12%
     *    +++ 12% 12.3kps 123Wpk/12%
     *    --- 12% 12.3kps 123Wpk/12%
     *    ^^^ 123m 123Wpk/12%
     *    vvv 123m 123Wpk/12%
     *
     * Size:
     *  47 + 19 + 27 + 27 + 20 + 20 → 160
     *  COMMAND_RESULT_MINIMAL: omit ^^^/vvv lines → 120
     */

    long pwr;
    long dist;

    // speed distances are in ~ 1/10 m based on cyclic counter in ID 59E
    // real distances per odometer (10 m resolution) are ~ 8-9% lower
    // compensate:

    float correction = ((float) odo_dist * 100) / pwr_dist;

    if (verbosity >= COMMAND_RESULT_MINIMAL)
    {
      writer->printf("Trip %.1fkm %.1fkph",
        (float) odo_dist / 100,
        (float) ((vx1_speedpwr[CAN_SPEED_CONST].spdcnt > 0)
            ? (vx1_speedpwr[CAN_SPEED_CONST].spdsum / vx1_speedpwr[CAN_SPEED_CONST].spdcnt) / 100
            : 0));

      dist = (float) pwr_dist * correction;
      pwr = pwr_use - pwr_rec;
      if ((pwr_use > 0) && (dist > 0))
      {
        writer->printf(" %ldWpk/%d%%",
          (pwr / dist * 10000 + ((pwr>=0)?WH_RND:-WH_RND)) / WH_DIV,
          (pwr_rec / (pwr_use/1000) + 5) / 10);
      }

      writer->printf(" SOC%+.1f%%=%.1f%%",
        (float) ((long)vx1_soc - (long)vx1_soc_tripstart) / 100,
        (float) vx1_soc / 100);

      // === 12% 123Wpk/12%
      pwr_use = vx1_speedpwr[CAN_SPEED_CONST].use;
      pwr_rec = vx1_speedpwr[CAN_SPEED_CONST].rec;
      dist = (float) vx1_speedpwr[CAN_SPEED_CONST].dist * correction;
      pwr = pwr_use - pwr_rec;
      if ((pwr_use > 0) && (dist > 0))
      {
        writer->printf("\n=== %d%% %ldWpk/%d%%",
          prc_const,
          (pwr / dist * 10000 + ((pwr>=0)?WH_RND:-WH_RND)) / WH_DIV,
          (pwr_rec / (pwr_use/1000) + 5) / 10);
      }

      // +++ 12% 12.3kps 123Wpk/12%
      pwr_use = vx1_speedpwr[CAN_SPEED_ACCEL].use;
      pwr_rec = vx1_speedpwr[CAN_SPEED_ACCEL].rec;
      dist = (float) vx1_speedpwr[CAN_SPEED_ACCEL].dist * correction;
      pwr = pwr_use - pwr_rec;
      if ((pwr_use > 0) && (dist > 0))
      {
        writer->printf("\n+++ %d%% %.1fkps %ldWpk/%d%%",
          prc_accel,
          (float) ((vx1_speedpwr[CAN_SPEED_ACCEL].spdcnt > 0)
              ? ((vx1_speedpwr[CAN_SPEED_ACCEL].spdsum * 10) / vx1_speedpwr[CAN_SPEED_ACCEL].spdcnt + 50) / 100
              : 0),
          (pwr / dist * 10000 + ((pwr>=0)?WH_RND:-WH_RND)) / WH_DIV,
          (pwr_rec / (pwr_use/1000) + 5) / 10);
      }

      // --- 12% 12.3kps 123Wpk/12%
      pwr_use = vx1_speedpwr[CAN_SPEED_DECEL].use;
      pwr_rec = vx1_speedpwr[CAN_SPEED_DECEL].rec;
      dist = (float) vx1_speedpwr[CAN_SPEED_DECEL].dist * correction;
      pwr = pwr_use - pwr_rec;
      if ((pwr_use > 0) && (dist > 0))
      {
        writer->printf("\n--- %d%% %.1fkps %ldWpk/%d%%",
          prc_decel,
          (float) ((vx1_speedpwr[CAN_SPEED_DECEL].spdcnt > 0)
              ? ((vx1_speedpwr[CAN_SPEED_DECEL].spdsum * 10) / vx1_speedpwr[CAN_SPEED_DECEL].spdcnt + 50) / 100
              : 0),
          (pwr / dist * 10000 + ((pwr>=0)?WH_RND:-WH_RND)) / WH_DIV,
          (pwr_rec / (pwr_use/1000) + 5) / 10);
      }

    } // if (verbosity >= COMMAND_RESULT_MINIMAL)

    if (verbosity >= COMMAND_RESULT_SMS)
    {
      // level distances are in 1 m and based on odometer
      // (no correction necessary)

      // ^^^ 123m 123Wpk/12%
      pwr_use = vx1_levelpwr[CAN_LEVEL_UP].use;
      pwr_rec = vx1_levelpwr[CAN_LEVEL_UP].rec;
      dist = vx1_levelpwr[CAN_LEVEL_UP].dist;
      pwr = pwr_use - pwr_rec;
      if ((pwr_use > 0) && (dist > 0))
      {
        writer->printf("\n^^^ %dm %ldWpk/%d%%",
          vx1_levelpwr[CAN_LEVEL_UP].hsum,
          (pwr / dist * 1000 + ((pwr>=0)?WH_RND:-WH_RND)) / WH_DIV,
          (pwr_rec / (pwr_use/1000) + 5) / 10);
      }

      // vvv 123m 123Wpk/12%
      pwr_use = vx1_levelpwr[CAN_LEVEL_DOWN].use;
      pwr_rec = vx1_levelpwr[CAN_LEVEL_DOWN].rec;
      dist = vx1_levelpwr[CAN_LEVEL_DOWN].dist;
      pwr = pwr_use - pwr_rec;
      if ((pwr_use > 0) && (dist > 0))
      {
        writer->printf("\nvvv %dm %ldWpk/%d%%",
          vx1_levelpwr[CAN_LEVEL_DOWN].hsum,
          (pwr / dist * 1000 + ((pwr>=0)?WH_RND:-WH_RND)) / WH_DIV,
          (pwr_rec / (pwr_use/1000) + 5) / 10);
      }

    } // if (verbosity >= COMMAND_RESULT_SMS)

    writer->puts("");

  } // Output power efficiency trip report

  return Success;
}
